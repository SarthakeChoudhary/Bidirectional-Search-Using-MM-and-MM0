def MM0(problem):
    
    from util import PriorityQueue
    
    def PathReverse(p):
        """
        Given a action list, return the reversed version of it.
        """
        path=[]
        for x in p:
            if x == 'NORTH':
                x= 'SOUTH'
                path.append(x)
            if x== 'SOUTH':
                x= 'NORTH'
                path.append(x)
            if x== 'WEST':
                x='EAST'
                path.append(x)
            if x== 'EAST':
                x='WEST'
                path.append(x) 
        return path[::-1]
    
    gF=0
    gB=0
    OpenF=PriorityQueue()
    OpenB=PriorityQueue()
    
    OpenF.push((problem.getStartState(),[],0),gF)
    OpenB.push((problem.getGoalState(),[],0),gB)
    
    ClosedF=[]
    ClosedB=[]
    
    cost=[]
    gFval=[]
    gBval=[]
    
    path=[]
    pathF=[]
    pathB=[]
    
    U= float('inf')
    
    while not OpenF.isEmpty() and not OpenB.isEmpty:
        
        StateF=OpenF.pop()[0]
        StateB=OpenB.pop()[0]
        gF=OpenF.pop()[2]
        gB=OpenB.pop()[2]
        
        epsilon=min(cost)
        gminF=min(gFval)
        gminB=min(gBval)
        
        
        prminF= 2*gF
        prminB= 2*gB
        
        C=min(prminF,prminB)
        
        if U <= max(C,gminF+gminB+epsilon):
            path=pathF+PathReverse(pathB)
            return path
        
        if C == prminF:
            if StateF not in ClosedF:
                ClosedF.append(StateF)
    
                SuccessorsF=problem.getSuccessors(StateF)
                for x in SuccessorsF:
                    OpenF.push((x[0], path+[x[1]], gF+x[2]),gF+x[2])
                    gFval.append(gF+x[2])
                    cost.append(x[2])
                    
                    if x[0] in OpenB:
                        pathF +=x[2]
                        U=min(U,gF+gB)
        else:
            if StateB not in ClosedB:
                ClosedF.append(StateB)
    
                SuccessorsB=problem.getSuccessors(StateB)
                for x in SuccessorsB:
                    OpenB.push((x[0], path+[x[1]], gF+x[2]),gB+x[2])
                    gBval.append(gB+x[2])
                    cost.append(x[2])
                    
                    if x[0] in OpenF:
                        pathB +=x[2]
                        U=min(U,gF+gB)
        return float('inf')
